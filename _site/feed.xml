<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-06-02T01:07:05+02:00</updated><id>http://localhost:4000//</id><title type="html">defsrc.com</title><subtitle>Discussing topics and going into details related to source code and software.
</subtitle><entry><title type="html">More robust JavaScript - The Maybe monad</title><link href="http://localhost:4000/software/javascript/2017/01/16/more-robust-javascript-maybe-monad.html" rel="alternate" type="text/html" title="More robust JavaScript - The Maybe monad" /><published>2017-01-16T19:58:02+01:00</published><updated>2017-01-16T19:58:02+01:00</updated><id>http://localhost:4000/software/javascript/2017/01/16/more-robust-javascript-maybe-monad</id><content type="html" xml:base="http://localhost:4000/software/javascript/2017/01/16/more-robust-javascript-maybe-monad.html">If you design API's (i.e. you write programs with more than one module or you
design libraries to be used by others[^ninternalapis]), then you make decisions on how then
application code will look like and behave.

Let's say that we need a module for interfacing with a word list, like a
dictionary. The module should expose a function named `getFirstMatch` that consumes
1 argument, a `RegExp`, and should return the first word in the word list that matches
that `RegExp`. We have a text file `words.txt` that contains the following:

```
aardvark
fox
lion
wolf
zebra
```

For the sake of brevity, we have a function, `load`, that parses a file as an
array with an element for each line in the file.

An initial implementation could look like:

**Module: `words-basic.js`**

```javascript
const words = load('./words.txt');
export function getFirstMatch(re) {
  for (let i = 0; i &lt; words.length; ++i)
    if (words[i].match(re) !== null) return words[i];
};
```

Then, some application code comes along and wants to use the above module:

**Module: `app-basic.js`**

```javascript
import {getFirstMatch} from 'words-basic'

const searchPatterns = [
  /aa/,
  /frob/
];

// for some reason, we want to log the length of the first word found matching
// each of the regices above.
searchPatterns.forEach(pat =&gt; {
  console.log(getFirstMatch(pat).length);
});
```

We incur a `TypeError`. Due to `getFirstMatch` returning a `null` as a result of
the  `RegExp` `/frob/` not matching anything.

What can we do to mitigate this?

1. One solution would be to document this in the `words` module, telling the
consumer that &quot;By using this function you agree to check for null, lest you want
to have TypeErrors thrown about&quot;.

2. Another solution would be to codify the error handling, or in other terms: force
consumer code to handle the case of failure.

Let's take a look at what the first solution could look like:

**Module: `app-nullcheck.js`**

```javascript
// some parts elided

searchPatterns.forEach(pat =&gt; {
  const result = getFirstMatch(pat);

  // Do the null-check, because the documentation said that the result might
  // be null. Er, wait, did it say anything about it being undefined? Better
  // check for that as well.
  if (result !== null &amp;&amp; result !== undefined) {
    console.log(result.length);
  }
  else {
    // Shucks, there was no word matching `pat`
    console.log(0);
  }
});
```

Looks OK, but keep in mind, nobody really forced you to bother taking care of
the crashing application (other than your raging client).

To implement the second solution, we would write our `words` module a bit
different:

**Module: `words-monadic.js`**

```javascript
import {Maybe} from 'ramda-fantasy';
const {Just, Nothing} = Maybe;

const words = load('./words.txt');
export function getFirstMatch(re) {
  for (let i = 0; i &lt; words.length; ++i)
    if (words[i].match(re) !== null) return Just(words[i]);
    // -------------------------------------^
    // We return Maybe.Just if the word was found

  // otherwise, we return Nothing, which indicate the absence of a value.
  // A bit similar to `null` but without all the null reference errors.
  return Nothing;
};
```

**Module: `app-monadic.js`**

```javascript
// some parts elided

searchPatterns.forEach(pat =&gt; {
  const result = getFirstMatch(pat)
    // here we are saying:
    // &quot;If the result is Just(x) we want to read x.length&quot;
    .map(word =&gt; word.length)
    // here we are saying:
    // &quot;Extract the value of the current Maybe, but if it's a Nothing,
    // then we default to `0`&quot;
    .getOrElse(0);

  console.log(result);
});
```

Personally, I find the second approach to be far superior to the first, because:

- It forces consumer code to take care of the possible failure state.
- It does so in a uniform way, i.e. no need to sometimes check for `null` and
other times check for `undefined` etc.
- It unifies the falsy values of javascript into one atom. I.e. one would not
need to worry about inadvertently checking whether `0` is false, as in:

```javascript
var result = 0; // zero here is an actual value, not the absence of one.
if (!result) {
  alert('ERROR: we got no result');
}
```

### I'm sold! Where do I find it?

There are a number of implementations in the wild that one could use. I like the
idea that some types of libraries should conform to a spec, and for this sort of
data type there is a
[well defined specification (fantasy land)][fantasy-land-spec]. The following
libraries conforms to this spec:

- [sanctuary/maybe][sanctuary-maybe]. On the plus side on using this library is
that you get a lot of extra goodies.

- [fantasy-options][fantasy-options-gh][^nalternativenames]. As discussed in
[this issue][fantasy-options-gh-name-issue], it might change the names of the
exported symbols soon, from `Option = Some a + None` to `Maybe = Just a + Nothing`,
so if you decide to use this, be ready to rewrite some code.

- [ramda-fantasy/maybe][ramda-fantasy-maybe-gh]. However, this library is declared
to be in an alpha state, so should not be used without consideration.


### Still not convinced?

I regret not being able to convince you of the merits of using the `Maybe` monad. Write a comment below and we'll talk things over.

---

##### Footnotes

[^ninternalapis]: Yes, everyone who has written code that is used by others, be it an internal API or an exposed API, have designed it. The word &quot;design&quot; being applied in a loose manner.
[^nalternativenames]: The `Maybe` monad is known to also be called `Option` and sometimes `Optional`.

[fantasy-land-spec]: https://github.com/fantasyland/fantasy-land
[fantasy-options-gh]: https://github.com/fantasyland/fantasy-options
[fantasy-options-gh-name-issue]: https://github.com/fantasyland/fantasy-options/issues/8
[ramda-fantasy-maybe-gh]: https://github.com/ramda/ramda-fantasy/blob/master/docs/Maybe.md
[sanctuary-maybe]: https://sanctuary.js.org/#maybe-type

[why1]: https://github.com/chrissrogers/maybe#why</content><category term="javascript" /><category term="API-design" /><category term="monads" /><category term="maybe-monad" /><summary type="html">If you design API’s (i.e. you write programs with more than one module or you
design libraries to be used by others1), then you make decisions on how then
application code will look like and behave.


  
    
      Yes, everyone who has written code that is used by others, be it an internal API or an exposed API, have designed it. The word “design” being applied in a loose manner. &amp;#8617;</summary></entry><entry><title type="html">Alacritty - an OpenGL powered terminal emulator</title><link href="http://localhost:4000/software/rust/2017/01/12/alacritty-opengl-powered-terminal-emulator.html" rel="alternate" type="text/html" title="Alacritty - an OpenGL powered terminal emulator" /><published>2017-01-12T14:58:02+01:00</published><updated>2017-01-12T14:58:02+01:00</updated><id>http://localhost:4000/software/rust/2017/01/12/alacritty-opengl-powered-terminal-emulator</id><content type="html" xml:base="http://localhost:4000/software/rust/2017/01/12/alacritty-opengl-powered-terminal-emulator.html">Today we're going to take a look at [Alacritty][alacritty-announcement]. The name, which I think is a portmanteau of alacrity and [TTY][jargon-tty], is a terminal emulator written in rust. Here's an excerpt from the project's README, which describes it in a nutshell:

&gt;Keep in mind that Alacritty is very much not looking to be a feature-rich terminal emulator with all sorts of bells and widgets. It's primarily a cross-platform, blazing fast tmux renderer that Just Works.

Personally, I've used the following terminal emulators to a greater extent:

- Sakura
- Terminator
- rxvt-unicode
- xterm
- eterm

Of which, to this date, I've found Sakura to be the most pleasant one to use, because of its simplicity and speed. Since Alacritty's goals are to be simple and fast, it might be a contender for my number one.

### Building

The project's README includes instructions on which dependencies are requried and how to build. I had to `rustup override set $(&lt;rustc-version)` (as stated in the README) because [copypasta][cargo-copypasta] wouldn't compile with the `nightly` release. Other than that, it was, more or less, a straight-forward `cargo build --release`, and a bit of waiting.

### Running

To try it out, I opened a new tmux session, split the window in two and executed `dd if=/dev/urandom | base64`, in order to generate some output.

![Alacritty test](/assets/img/post1/alacritty_1-compressor.png)
*Alacritty with a tmux session having two zsh instances running `dd if=/dev/urandom | base64`*

I did the same with Sakura, and it was actually noticeably laggy, whereas Alacritty was pretty smooth. Now, this test, in and of itself, is not sufficient to draw a final conclusion regarding which is faster. I presume that factors, such as [ANSI][jargon-ansi] colours and unicode glyphs, play a role as well. There is [an issue][alacritty-benchmark-issue] regarding this on the project's issue tracker, where one can find some examples of ways to benchmark a terminal emulator.

### Caveats

Running this on an older machine may not be possible just yet, due to Alacritty needing support for `GLSL 3.30`, as discussed in [this issue][alacritty-glsl-issue]. Trying to run Alacritty with an Intel M 530 integrated graphics controller did not work, whereas it did work on a newer ATI Radeon M. Hopefully, this issue is solved so that one can use Alacritty even on somewhat dated hardware.

### Activity

The first commit to the repository was almost one year ago and it is an [active project][alacritty-pulse]. There seem to be a bit of duplication regarding issues, especially issues regarding performance/benchmarking.

### Links

- [Joe Wilm's intro to Alacritty][alacritty-announcement]
- [Alacritty@GitHub][alacritty-gh]

[alacritty-announcement]: http://blog.jwilm.io/announcing-alacritty/
[alacritty-gh]: https://github.com/jwilm/alacritty
[alacritty-pulse]: https://github.com/jwilm/alacritty/pulse
[alacritty-benchmark-issue]: https://github.com/jwilm/alacritty/issues/289
[alacritty-glsl-issue]: https://github.com/jwilm/alacritty/issues/128
[cargo-copypasta]: https://crates.io/crates/copypasta

[jargon-tty]: http://catb.org/jargon/html/T/tty.html
[jargon-ansi]: http://catb.org/jargon/html/A/ANSI-standard.html
[sakura-home]: https://launchpad.net/sakura
[terminator-lp]: https://launchpad.net/terminator</content><category term="rust" /><category term="terminal-emulator" /><category term="opengl" /><category term="cli" /><summary type="html">Today we’re going to take a look at Alacritty. The name, which I think is a portmanteau of alacrity and TTY, is a terminal emulator written in rust. Here’s an excerpt from the project’s README, which describes it in a nutshell:</summary></entry></feed>
